import sys
import dns.query
from dns.exception import DNSException
import datetime
import time
import logging

logging.basicConfig(level=logging.WARNING)

def root_servers_ips():
    return ['198.41.0.4','199.9.14.201','192.33.4.12','199.7.91.13','192.203.230.10','192.5.5.241','192.112.36.4','198.97.190.53','192.36.148.17','192.58.128.30','193.0.14.129','199.7.83.42','202.12.27.33']

def get_root_ZSK_hash():
    return ['19036 8 2 49aac11d7b6f6446702e54a1607371607a1a41855200fd2ce1cdde32f24e8fb5', '20326 8 2 e06d44b80b8f1d39a95c0b0d7c65d08458e880409bbc683457104237c7f8ec8d']

def verifying_root_server(dns_name,server,ksk_ds_hash):
    #Steps:
    # 1. Verify that the record is coming from the root only by verifying the DS record by creating a hash of PubKSK and 
    #    verifying it with the already available static KSK hash from ICAN website.
    # 2. Also verify that the DNSKeys(pub ZSK and Pub KSK) are genuine by validating it agains the RRSig sent along with it by decrypting using PubKSK)
    response = resolve(dns_name,server,dns.rdatatype.DNSKEY,True)
    pub_ksk, rr_set_ksk = dnskey_from_answer(response.answer)
    rr_set_zsk = response.answer
    rr_sig = get_rr_sig(response.answer)
    ds_pub_ksk = make_hash_for_key(dns_name,pub_ksk)
    if ds_pub_ksk_matches(ksk_ds_hash,ds_pub_ksk,dns_name) and verify_dnskeys_rrsig(rr_set_ksk,rr_sig,dns_name):
        logging.info("Verification Successfull for: " + str(dns_name))
        return True, rr_set_zsk
    else:
        logging.info("Verification Unsuccessfull for: " + str(dns_name))
        return False, None
#Matches if the hash provided and the hash generated by hashing the Pub KSK is same
def ds_pub_ksk_matches(zsk_ds_hash,ds_pub_zsk,dns_name):
    for hash in zsk_ds_hash:
        if hash == str(ds_pub_zsk):
            logging.info("DS Verification Successfull for: " + str(dns_name))
            return True
    return False

#Verifies that the DNSKEYs are valid by verifiyin the RRSET with RRSIG
def verify_dnskeys_rrsig(rr_set,rr_sig,dns_name):
    try:
	    dns.dnssec.validate(rr_set, rr_sig,{dns_name:rr_set})
    except dns.dnssec.ValidationFailure:
	    logging.info("DNSKeys Verification Unsuccessfull for: " + str(dns_name))
	    return False
    logging.info("DNSKeys Verification Successfull for: " + str(dns_name))
    return True

#Helper function to et the RRSIG
def get_rr_sig(answers):
    for answer in answers:
        if(answer.rdtype == dns.rdatatype.RRSIG):
            return answer
    return None

#Helper function to get the DS Record
def get_DS_from_authority(authority):
    for rr_set in authority:
        if rr_set.rdtype == dns.rdatatype.DS:
            return rr_set
    return None

def dnskey_from_answer(answers):
    if len(answers) == 0:
	    return None, None
    for answer in answers:
	    if (answer.rdtype == dns.rdatatype.DNSKEY):
		    for rr_record in answer:
			    if rr_record.flags == 257: 
				    return rr_record, answer
    return None, None

#Generate the hash of the key
def make_hash_for_key(dns_name,key):
    return dns.dnssec.make_ds(dns_name, key, 'sha256')

def split_domain(domain):
    return domain.split('.')

#Verifies the server is valid 
def verify_server(servers):
    dns_name = dns.name.from_text('.')
    for server in servers:
        verified, rr_set = verifying_root_server(dns_name,server,get_root_ZSK_hash())
        if verified:
            return True
    return False

def extract_ds_from_authority_and_verify(response):
    child_ds = None
    child_algo = None
    if len(response.authority) > 0:
		#Extract the DS field of authorative section for child and algorithm
	    for auth in response.authority:
		    if (auth.rdtype == dns.rdatatype.DS):
			    child_ds = auth[0]
			    if (auth[0].digest_type == 1):
			    	child_algo = "sha1"
			    elif (auth[0].digest_type == 2):
			    	child_algo = "sha256"
			    # break
    return child_ds, child_algo

#Parse the opub_zsk from the response
def pub_zsk_from_answer(answers):
    if len(answers) == 0:
	    return None, None
    for answer in answers:
	    if (answer.rdtype == dns.rdatatype.DNSKEY):
		    for rr_record in answer:
			    if rr_record.flags == 257: 
				    return rr_record, answer
    return None, None

def resolveDomain(domain,servers,rdtype):
    n = split_domain(domain)
    my_servers = servers
    for i in range(len(n), 0, -1):
        sub_domain = '.'.join(n[i-1:])
        logging.info('sub_domain: '+ str(sub_domain) + '  server: ' + my_servers[0])
        next_servers = _resolve(sub_domain,my_servers,rdtype)
        my_servers = next_servers
    return my_servers

def _resolve(sub_domain, my_servers, rdtype):
    dns_name = dns.name.from_text(sub_domain)
    response = get_next_server(dns_name,my_servers,rdtype)
    check_dnssec_support(response)
    child_ds, child_algo = extract_ds_from_authority_and_verify(response)
    ds_list = []
    ds_list.append(str(child_ds))
    if len(response.answer) > 0: 
        return response.answer[0].to_text().split(" ")[-1]
    elif ((len(response.authority) > 0) and (response.authority[0].rdtype == dns.rdatatype.SOA)):
        #We set the same server for next round as well
        return my_servers
    elif len(response.authority)>0 and len(response.additional)>0:
        duh_servers = get_ip_from_ns(response,dns_name)
        #Here I extract the DS for the child node for the next iteration and also verify that the DS is correct by decrypting the RRSIG using Pub_ZSK
        # logging.info(ds_list[0])
        verified, rr_set = verifying_root_server(dns_name,duh_servers[0],ds_list)
        logging.debug(rr_set[0])
        if(not verified):
            print("DNSSEC Validation Failed")
            exit()
        # print('XYZ2',duh_servers)
        return duh_servers
    else:
        ns_names = get_ns_from_authority(response,dns_name) #ns1.google.com.
        # print("XYZ3", ns_names)
        something = []
        for name in ns_names:
            something = resolveDomain(name,root_servers_ips(),rdtype)
            verified, rr_set = verifying_root_server(dns_name,something,ds_list)
            # print("XYZ4",something)
            if(not verified):
                print("DNSSEC Validation Failed")
                exit()
            if something:
                break
        # next_servers = get_next_server(sub_domain,[something],rdtype).answer[0].to_text().split(" ")[-1]
        return [something]
#To check whether DNSSEc is suported or not
def check_dnssec_support(response):
    ds_records = []
    for auth in response.authority:
        if auth.rdtype == dns.rdatatype.DS:
            ds_records.append(auth[0])
    if(len(ds_records)==0):
        print("DNSSEC not supported")
        exit()

def get_ip_from_ns(response,dns_name):
    ns_names = get_ns_from_authority(response,dns_name)
    list_of_ips = ip_for_ns_from_additional(response,ns_names)
    list_1= []
    for k,v in list_of_ips.items():
        list_1.append(v)
    return list_1

def get_next_server(dns_name,servers,type):
    response = None
    for server in servers:
        response = resolve(dns_name,server, type, True)
        if response:
            break
    return response

def get_ns_from_authority(response,dns_name):
    ns_names = []
    try:
        ns_rrset = response.find_rrset(response.authority, dns_name, dns.rdataclass.IN, dns.rdatatype.NS)
        for rr in ns_rrset:
            ns_names.append(rr.to_text())
    except KeyError:
        logging.info('Invalid Key')
    return ns_names

def ip_for_ns_from_additional(response,ns_names):
    ns_ips = {}
    for name in ns_names:
        somename = dns.name.from_text(name)
        try:
            ns_rrset = response.find_rrset(response.additional, somename, dns.rdataclass.IN, dns.rdatatype.A)
            for rr in ns_rrset:
                ns_ips[name] = rr.to_text()
        except KeyError:
            logging.info('Invalid Key')
    return ns_ips

def resolve(dns_name,server,rdatatype=dns.rdatatype.A,dnssec=False):
    query = dns.message.make_query(dns_name, rdatatype,want_dnssec = dnssec)
    response = dns.query.udp(query,server)
    return response

def beautify_output(result, type, query_time):
	if(len(result.answer)>0):
		rrset = result.answer[0]
		rr = rrset[0]	
		if(type == "A" and rr.rdtype == dns.rdatatype.CNAME):
			cname_ans = resolveDomain(str(rr),root_servers_ips(), dns.rdatatype.from_text("A"))
			result.answer += cname_ans.answer
	output = ""
	output += "QUESTION SECTION:\n" + result.question[0].to_text() + "\n\n" + "ANSWER SECTION:\n"
	for ans in result.answer:
		output += ans.to_text()+"\n"
	output += "\n" + "Query Time: "
	output += str(query_time) + " sec\n"
	currentDT = datetime.datetime.now()
	output += currentDT.strftime("%a %b %d %H:%M:%S %Y\n")
	output += "MSG SIZE rcvd: " + str(sys.getsizeof(result))
	return output

if __name__ == "__main__":
    domain_name = sys.argv[1]
    type = sys.argv[2]
    servers = root_servers_ips()
    domain = domain_name.replace("www.","")
    print(domain)
    start_time = time.time()
    rdtype = dns.rdatatype.from_text(type)
    if(not verify_server(servers)):
        exit()
    answer = resolveDomain(domain,servers,rdtype)
    for ans in answer:
        finalanswer = resolve(domain,ans,type)
        if finalanswer:
            break
    end_time = time.time()
    print("Final Answer",beautify_output(finalanswer,type,end_time-start_time))
